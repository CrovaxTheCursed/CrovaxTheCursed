import binascii
import lief
from ipaddress import IPv4Address

def get_decryption_args(start_addr):
	for instr in start_addr.medium_level_il.instructions:
		if instr.operation == MediumLevelILOperation.MLIL_CALL:
			data_size = instr.params[1].value.value
			enc_blob = bv.read(instr.params[2].value.value, data_size)
			key = bv.read(instr.params[3].value.value, 0x80) # replace 0x80 for 0x5a if analyzing older samples
	return enc_blob, key


def parse_pe(file_path):
    """Load binary from filepath"""
    binary = lief.parse(file_path)
    return binary

# decrypt function works perfectly
def decrypt(key, data, index):
	dec_str = [data[i] ^  key[i % len(key)] for i in range(len(data))]
	return bytes(dec_str[index:]).decode().split('\x00')[0]

def decrypt_rsrc(rsrc_data, key):
    sha = Transform['SHA1']
    sha_key = sha.encode(key)
    rc4 = Transform['RC4']
    decrypt_data = rc4.encode(rsrc_data, {'key':sha_key})

    decrypted_rsrc = rc4.encode(decrypt_data[40:], {'key':decrypt_data[20:40]})
    return decrypted_rsrc

# mark up db file
def mark_db(comment_address, decrytped_str):#dec_addr):
	##bv.write(dec_addr, unc_str)
	#print(f'Setting {decrytped_str} at:{hex(comment_address)}\n')
	bv.set_comment_at(comment_address, decrytped_str)

def extract_resource_data(filename):
    rsrc = []
    pe = parse_pe(filename)
    rsrc_manager = pe.resources_manager

    modes = [ lief.PE.RESOURCE_TYPES.RCDATA, lief.PE.RESOURCE_TYPES.BITMAP]

    for mode in modes:
        try:
            for res in rsrc_manager.get_node_type(mode).childs:
                for data in res.childs:
                    rsrc.append(bytes(data.content))
            break
        except:
            continue
    return min(rsrc, key=len), max(rsrc, key=len)


def print_data(data_list):
    for item in data_list:
        print(item)

def valid_strings(string):
    """Check if all strings are ascii encoding"""
    return string.isascii()#  for string in strings]

def perform_decryption(address):
	decrypted_string = list()
	encrypted_data, encrypt_key = get_decryption_args(address)
	for addr in set(address.callers):
		for instruct in addr.medium_level_il.instructions:
			if (instruct.operation == MediumLevelILOperation.MLIL_CALL and str(instruct.dest) == hex(address.start)):
				string_index = instruct.params[0].value.value

				#print(f'Address:{hex(instruct.address)}:-->{hex(string_index)}')
				comment_addr = instruct.address
				decrypt_string = decrypt(encrypt_key, encrypted_data, string_index)
				decrypted_string.append(decrypt_string)
				mark_db(comment_addr, decrypt_string)
	return [bytes(string, 'utf-8') for string in decrypted_string]

# parse and format config for new Qbot
def get_c2_new(rsrc_data):
    res = rsrc_data[21:]
    comms =[]
    i = 0
    while (i < len(res)):
        ip = res[i:i+4]
        port = res[i+4:i+6]
        com =f'{IPv4Address(ip)}:{int(binascii.hexlify(port), 16)}'
        i = i + 8
        comms.append(com)
    return comms


# format Botnet information
def get_botnet_info(bot):
    info = bot.splitlines()
    bot_info = [i.decode('latin1').split('=') for i in info]

    if len(bot_info[0]) == 3:
        return f'Botnet:{bot_info[0][2]} Campaign:{bot_info[1][1]}'

    return f'Botnet:{bot_info[0][1]} Campaign:{bot_info[1][1]}'

def get_c2_new(rsrc_data):
    res = rsrc_data[21:]
    comms =[]
    i = 0
    while (i < len(res)):
        ip = res[i:i+4]
        port = res[i+4:i+6]
        com =f'{IPv4Address(ip)}:{int(binascii.hexlify(port), 16)}'
        i = i + 8
        comms.append(com)
    return comms

def resolve_c2(keys):
    print(keys)
    filename = bv.file.original_filename
    bot, c2 = extract_resource_data(filename)
    for key in keys:
        try:
            bot_id = get_botnet_info(decrypt_rsrc(bot, key))
            c2_ips = get_c2_new(decrypt_rsrc(c2, key))

            if valid_strings(bot_id):
                return bot_id,c2_ips
        except:
            pass

#0x1000905b, 0x10009042, 0x10001881,
address_list = [0x10001881]


for address in address_list:
	addr = bv.get_function_at(address)
	key_list = perform_decryption(addr)

bot, c2 = resolve_c2(key_list)

if bot:
     print("****Configuration decrypted*****\n")
     print(f'{bot}')
     print(f'C2 IPs\n{c2}')
